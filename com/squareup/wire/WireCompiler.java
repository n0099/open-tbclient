package com.squareup.wire;

import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.EnumType;
import com.squareup.protoparser.ExtendDeclaration;
import com.squareup.protoparser.MessageType;
import com.squareup.protoparser.Option;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.Type;
import com.squareup.wire.IO;
import com.squareup.wire.Message;
import java.io.File;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;
import javax.lang.model.element.Modifier;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
/* loaded from: classes.dex */
public class WireCompiler {
    private static /* synthetic */ int[] $SWITCH_TABLE$com$squareup$protoparser$MessageType$Label = null;
    private static final String CODE_GENERATED_BY_WIRE = "Code generated by Wire protocol buffer compiler, do not edit.";
    private static final String FILES_FLAG = "--files=";
    private static final String JAVA_OUT_FLAG = "--java_out=";
    static final String LINE_WRAP_INDENT = "    ";
    private static final String NO_OPTIONS_FLAG = "--no_options";
    private static final String PROTO_PATH_FLAG = "--proto_path=";
    private static final String REGISTRY_CLASS_FLAG = "--registry_class=";
    private static final String ROOTS_FLAG = "--roots=";
    private boolean emitOptions;
    private final Map<String, String> enumDefaults;
    private final Set<String> enumTypes;
    private final Map<String, Set<String>> enumValuesByScope;
    private final List<String> extensionClasses;
    private final Map<String, ExtensionInfo> extensionInfo;
    private final Map<String, FieldInfo> fieldMap;
    private final IO io;
    private final Map<String, String> javaSymbolMap;
    private final Set<String> javaSymbols;
    private final OptionsMapMaker optionsMapMaker;
    private final String outputDirectory;
    private ProtoFile protoFile;
    private String protoFileName;
    private final String registryClass;
    private final String repoPath;
    private String sourceFileName;
    private final List<String> sourceFileNames;
    private String typeBeingGenerated;
    private final Set<String> typesToEmit;
    private JavaWriter writer;
    static final Set<String> DEFAULT_FIELD_OPTION_KEYS = new LinkedHashSet(Arrays.asList("default", "deprecated", "packed"));
    private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public enum LoadSymbolsPass {
        LOAD_TYPES,
        LOAD_FIELDS;

        /* JADX DEBUG: Replace access to removed values field (ENUM$VALUES) with 'values()' method */
        /* renamed from: values  reason: to resolve conflict with enum method */
        public static LoadSymbolsPass[] valuesCustom() {
            LoadSymbolsPass[] valuesCustom = values();
            int length = valuesCustom.length;
            LoadSymbolsPass[] loadSymbolsPassArr = new LoadSymbolsPass[length];
            System.arraycopy(valuesCustom, 0, loadSymbolsPassArr, 0, length);
            return loadSymbolsPassArr;
        }
    }

    static /* synthetic */ int[] $SWITCH_TABLE$com$squareup$protoparser$MessageType$Label() {
        int[] iArr = $SWITCH_TABLE$com$squareup$protoparser$MessageType$Label;
        if (iArr == null) {
            iArr = new int[MessageType.Label.values().length];
            try {
                iArr[MessageType.Label.OPTIONAL.ordinal()] = 1;
            } catch (NoSuchFieldError e) {
            }
            try {
                iArr[MessageType.Label.REPEATED.ordinal()] = 3;
            } catch (NoSuchFieldError e2) {
            }
            try {
                iArr[MessageType.Label.REQUIRED.ordinal()] = 2;
            } catch (NoSuchFieldError e3) {
            }
            $SWITCH_TABLE$com$squareup$protoparser$MessageType$Label = iArr;
        }
        return iArr;
    }

    public static void main(String[] strArr) {
        String str = null;
        ArrayList arrayList = new ArrayList();
        ArrayList arrayList2 = new ArrayList();
        boolean z = true;
        String str2 = null;
        String str3 = null;
        for (int i = 0; i < strArr.length; i++) {
            if (strArr[i].startsWith(PROTO_PATH_FLAG)) {
                str3 = strArr[i].substring(PROTO_PATH_FLAG.length());
            } else if (strArr[i].startsWith(JAVA_OUT_FLAG)) {
                str2 = strArr[i].substring(JAVA_OUT_FLAG.length());
            } else if (strArr[i].startsWith(FILES_FLAG)) {
                String substring = strArr[i].substring(FILES_FLAG.length());
                if (substring != null && "*".equals(substring)) {
                    File[] listFiles = new File(str3).listFiles();
                    for (int i2 = 0; listFiles != null && i2 < listFiles.length; i2++) {
                        String name = listFiles[i2].getName();
                        if (name.endsWith("proto")) {
                            arrayList.add(name);
                        }
                    }
                } else {
                    arrayList.addAll(Arrays.asList(new Scanner(new File(substring), "UTF-8").useDelimiter("\\A").next().split(IOUtils.LINE_SEPARATOR_UNIX)));
                }
            } else if (strArr[i].startsWith(ROOTS_FLAG)) {
                arrayList2.addAll(Arrays.asList(strArr[i].substring(ROOTS_FLAG.length()).split(",")));
            } else if (strArr[i].startsWith(REGISTRY_CLASS_FLAG)) {
                str = strArr[i].substring(REGISTRY_CLASS_FLAG.length());
            } else if (strArr[i].equals(NO_OPTIONS_FLAG)) {
                z = false;
            } else {
                arrayList.add(strArr[i]);
            }
        }
        if (str2 == null) {
            System.err.println("Must specify --java_out= flag");
            System.exit(1);
        }
        if (str3 == null) {
            str3 = System.getProperty("user.dir");
            System.err.println("--proto_path= flag not specified, using current dir " + str3);
        }
        new WireCompiler(str3, arrayList, arrayList2, str2, str, z).compile();
    }

    public WireCompiler(String str, List<String> list, List<String> list2, String str2, String str3, boolean z) {
        this(str, list, list2, str2, str3, z, new IO.FileIO());
    }

    WireCompiler(String str, List<String> list, List<String> list2, String str2, String str3, boolean z, IO io) {
        this.typesToEmit = new LinkedHashSet();
        this.javaSymbolMap = new LinkedHashMap();
        this.javaSymbols = new LinkedHashSet();
        this.enumTypes = new LinkedHashSet();
        this.enumDefaults = new LinkedHashMap();
        this.enumValuesByScope = new LinkedHashMap();
        this.extensionInfo = new LinkedHashMap();
        this.fieldMap = new LinkedHashMap();
        this.extensionClasses = new ArrayList();
        this.optionsMapMaker = new OptionsMapMaker(this);
        this.typeBeingGenerated = "";
        this.emitOptions = false;
        this.repoPath = str;
        this.typesToEmit.addAll(list2);
        this.sourceFileNames = list;
        this.outputDirectory = str2;
        this.registryClass = str3;
        this.emitOptions = z;
        this.io = io;
    }

    public void compile() {
        LinkedHashMap linkedHashMap = new LinkedHashMap();
        Iterator<String> it = this.sourceFileNames.iterator();
        while (it.hasNext()) {
            String str = String.valueOf(this.repoPath) + File.separator + it.next();
            ProtoFile parse = this.io.parse(str);
            linkedHashMap.put(str, parse);
            loadSymbols(parse);
        }
        if (!this.typesToEmit.isEmpty()) {
            System.out.println("Analyzing dependencies of root types.");
            findDependencies(linkedHashMap.values());
        }
        for (Map.Entry entry : linkedHashMap.entrySet()) {
            this.sourceFileName = (String) entry.getKey();
            this.protoFile = (ProtoFile) entry.getValue();
            this.protoFileName = protoFileName(this.protoFile.getFileName());
            System.out.println("Compiling proto source file " + this.sourceFileName);
            compileOne();
        }
        if (this.registryClass != null) {
            emitRegistry();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean emitOptions() {
        return this.emitOptions;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ProtoFile getProtoFile() {
        return this.protoFile;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public OptionsMapMaker getOptionsMapMaker() {
        return this.optionsMapMaker;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public JavaWriter getWriter() {
        return this.writer;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getEnumDefault(String str) {
        return this.enumDefaults.get(str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public FieldInfo getField(String str) {
        return this.fieldMap.get(str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String javaName(ProtoFile protoFile, MessageType messageType, String str) {
        String scalarType = TypeInfo.scalarType(str);
        return scalarType != null ? scalarType : shortenJavaName(protoFile, javaName(fullyQualifiedName(protoFile, messageType, str)));
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean fullyQualifiedNameIsOutsidePackage(String str) {
        return (str == null || getJavaPackage().equals(getPackageFromFullyQualifiedJavaName(str))) ? false : true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String prefixWithPackageName(String str) {
        return prefixWithPackageName(this.protoFile, str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean hasFields(Type type) {
        return (type instanceof MessageType) && !((MessageType) type).getFields().isEmpty();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean hasExtensions(MessageType messageType) {
        return !messageType.getExtensions().isEmpty();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getTrailingSegment(String str) {
        int lastIndexOf = str.lastIndexOf(46);
        return lastIndexOf == -1 ? str : str.substring(lastIndexOf + 1);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ExtensionInfo getExtension(String str) {
        return this.extensionInfo.get(str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getInitializerForType(String str, String str2) {
        if ("Boolean".equals(str2)) {
            if (str == null) {
                str = "false";
            }
            return str;
        } else if ("Integer".equals(str2)) {
            return str == null ? "0" : toInt(str);
        } else if ("Long".equals(str2)) {
            return str == null ? "0L" : String.valueOf(toLong(str)) + "L";
        } else if ("Float".equals(str2)) {
            return str == null ? "0F" : String.valueOf(str) + "F";
        } else if ("Double".equals(str2)) {
            return str == null ? "0D" : String.valueOf(str) + "D";
        } else if ("String".equals(str2)) {
            return quoteString(str);
        } else {
            if ("ByteString".equals(str2)) {
                if (str == null) {
                    return "ByteString.EMPTY";
                }
                return "ByteString.of(\"" + Stringer.encode(str.getBytes(ISO_8859_1)) + "\")";
            }
            throw new WireCompilerException(String.valueOf(str2) + " is not an allowed scalar type");
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isEnum(String str) {
        return this.enumTypes.contains(str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String javaName(MessageType messageType, String str) {
        String scalarType = TypeInfo.scalarType(str);
        return scalarType != null ? scalarType : shortenJavaName(javaName(fullyQualifiedName(messageType, str)));
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String javaName(String str) {
        return this.javaSymbolMap.get(str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String fullyQualifiedName(MessageType messageType, String str) {
        return fullyQualifiedName(this.protoFile, messageType, str);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String shortenJavaName(String str) {
        return shortenJavaName(this.protoFile, str);
    }

    private void compileOne() {
        String javaPackage;
        this.typeBeingGenerated = "";
        if (hasExtends()) {
            try {
                String str = "Ext_" + this.protoFileName;
                this.writer = this.io.getJavaWriter(this.outputDirectory, getJavaPackage(), str);
                emitExtensionClass();
                String str2 = String.valueOf(javaPackage) + "." + str;
                System.out.println("wrote extension class " + str2);
                this.extensionClasses.add(str2);
            } finally {
                if (this.writer != null) {
                    this.writer.close();
                }
            }
        }
        for (Type type : this.protoFile.getTypes()) {
            if (shouldEmitType(type.getFullyQualifiedName())) {
                String str3 = this.typeBeingGenerated;
                this.typeBeingGenerated = String.valueOf(this.typeBeingGenerated) + type.getName() + ".";
                emitMessageClass(type);
                this.typeBeingGenerated = str3;
            }
        }
    }

    private boolean hasFieldOption(List<Type> list) {
        for (Type type : list) {
            if (type instanceof MessageType) {
                for (MessageType.Field field : ((MessageType) type).getFields()) {
                    for (Option option : field.getOptions()) {
                        if (!DEFAULT_FIELD_OPTION_KEYS.contains(option.getName())) {
                            return true;
                        }
                    }
                }
                continue;
            }
        }
        return false;
    }

    private boolean hasMessageOption(List<Type> list) {
        for (Type type : list) {
            if ((type instanceof MessageType) && !((MessageType) type).getOptions().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private void getTypes(Type type, List<Type> list) {
        list.add(type);
        for (Type type2 : type.getNestedTypes()) {
            getTypes(type2, list);
        }
    }

    private void emitRegistry() {
        int lastIndexOf = this.registryClass.lastIndexOf(".");
        String substring = this.registryClass.substring(0, lastIndexOf);
        String substring2 = this.registryClass.substring(lastIndexOf + 1);
        try {
            this.writer = this.io.getJavaWriter(this.outputDirectory, substring, substring2);
            this.writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE, new Object[0]);
            this.writer.emitPackage(substring);
            this.writer.emitImports("java.util.List");
            this.writer.emitEmptyLine();
            this.writer.emitStaticImports("java.util.Arrays.asList", "java.util.Collections.unmodifiableList");
            this.writer.emitEmptyLine();
            this.writer.beginType(substring2, "class", EnumSet.of(Modifier.PUBLIC, Modifier.FINAL));
            this.writer.emitEmptyLine();
            StringBuilder sb = new StringBuilder("unmodifiableList(asList(\n");
            int size = this.extensionClasses.size();
            for (int i = 0; i < size; i++) {
                sb.append(this.extensionClasses.get(i));
                sb.append(".class");
                if (i < size - 1) {
                    sb.append(",\n");
                }
            }
            sb.append("))");
            this.writer.emitAnnotation("SuppressWarnings(\"unchecked\")");
            this.writer.emitField("List<Class<?>>", "EXTENSIONS", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL), sb.toString());
            this.writer.emitEmptyLine();
            this.writer.beginMethod(null, substring2, EnumSet.of(Modifier.PRIVATE), new String[0]);
            this.writer.endMethod();
            this.writer.endType();
        } finally {
            if (this.writer != null) {
                this.writer.close();
            }
        }
    }

    private boolean shouldEmitType(String str) {
        return this.typesToEmit.isEmpty() || this.typesToEmit.contains(str);
    }

    private void findDependencies(Collection<ProtoFile> collection) {
        LinkedHashSet linkedHashSet = new LinkedHashSet();
        int size = this.typesToEmit.size();
        while (true) {
            int i = size;
            for (ProtoFile protoFile : collection) {
                findDependenciesHelper(protoFile, linkedHashSet);
            }
            size = this.typesToEmit.size();
            if (size == i) {
                return;
            }
        }
    }

    private void findDependenciesHelper(ProtoFile protoFile, Set<String> set) {
        for (String str : protoFile.getDependencies()) {
            if (!set.contains(str)) {
                loadSymbols(this.io.parse(String.valueOf(this.repoPath) + File.separator + str));
                set.add(str);
            }
        }
        for (ExtendDeclaration extendDeclaration : protoFile.getExtendDeclarations()) {
            this.typesToEmit.add(extendDeclaration.getFullyQualifiedName());
            for (MessageType.Field field : extendDeclaration.getFields()) {
                this.typesToEmit.add(prefixWithPackageName(protoFile, field.getType()));
            }
        }
        addDependencies(protoFile.getTypes(), String.valueOf(getJavaPackage(protoFile)) + ".");
    }

    private void addDependencies(List<Type> list, String str) {
        for (Type type : list) {
            String name = type.getName();
            String fullyQualifiedName = type.getFullyQualifiedName();
            if ((type instanceof MessageType) && this.typesToEmit.contains(fullyQualifiedName)) {
                for (MessageType.Field field : ((MessageType) type).getFields()) {
                    if (!TypeInfo.isScalar(field.getType())) {
                        addDependencyBranch(fullyQualifiedName((MessageType) type, field.getType()));
                    }
                }
            }
            addDependencies(type.getNestedTypes(), String.valueOf(str) + name + ".");
        }
    }

    private void addDependencyBranch(String str) {
        while (typeIsComplete(str)) {
            this.typesToEmit.add(str);
            str = removeTrailingSegment(str);
        }
    }

    private String removeTrailingSegment(String str) {
        int lastIndexOf = str.lastIndexOf(46);
        return lastIndexOf == -1 ? "" : str.substring(0, lastIndexOf);
    }

    public String getTypeBeingGenerated() {
        return this.typeBeingGenerated.substring(0, this.typeBeingGenerated.length() - 1);
    }

    private void loadSymbols(ProtoFile protoFile) {
        loadSymbolsHelper(protoFile, new LinkedHashSet(), LoadSymbolsPass.LOAD_TYPES);
        loadSymbolsHelper(protoFile, new LinkedHashSet(), LoadSymbolsPass.LOAD_FIELDS);
    }

    private void loadSymbolsHelper(ProtoFile protoFile, Set<String> set, LoadSymbolsPass loadSymbolsPass) {
        for (String str : protoFile.getDependencies()) {
            if (!set.contains(str)) {
                loadSymbolsHelper(this.io.parse(String.valueOf(this.repoPath) + File.separator + str), set, loadSymbolsPass);
                set.add(str);
            }
        }
        addTypes(protoFile.getTypes(), String.valueOf(getJavaPackage(protoFile)) + ".", loadSymbolsPass);
        addExtensions(protoFile);
    }

    private void addExtensions(ProtoFile protoFile) {
        String fullyQualifiedName;
        for (ExtendDeclaration extendDeclaration : protoFile.getExtendDeclarations()) {
            for (MessageType.Field field : extendDeclaration.getFields()) {
                String type = field.getType();
                String javaName = javaName(protoFile, null, type);
                if (javaName == null) {
                    javaName = javaName(protoFile, null, prefixWithPackageName(protoFile, type));
                }
                String shortenJavaName = shortenJavaName(protoFile, javaName);
                String prefixWithPackageName = prefixWithPackageName(protoFile, field.getName());
                boolean isScalar = TypeInfo.isScalar(type);
                boolean z = !isScalar && isEnum(fullyQualifiedName(protoFile, null, type));
                if (isScalar) {
                    fullyQualifiedName = field.getType();
                    shortenJavaName = fullyQualifiedName;
                } else if (z) {
                    fullyQualifiedName = fullyQualifiedName(protoFile, null, type);
                    shortenJavaName = fullyQualifiedName;
                } else {
                    fullyQualifiedName = fullyQualifiedName(protoFile, null, type);
                }
                String protoFileName = protoFileName(protoFile.getFileName());
                this.extensionInfo.put(prefixWithPackageName, new ExtensionInfo(shortenJavaName, fullyQualifiedName, protoFileName, String.valueOf(getJavaPackage(protoFile)) + ".Ext_" + protoFileName, field.getLabel()));
            }
        }
    }

    String getJavaPackage(ProtoFile protoFile) {
        String javaPackage = protoFile.getJavaPackage();
        return javaPackage == null ? "" : javaPackage;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getJavaPackage() {
        return getJavaPackage(this.protoFile);
    }

    private void addTypes(List<Type> list, String str, LoadSymbolsPass loadSymbolsPass) {
        for (Type type : list) {
            String name = type.getName();
            if (loadSymbolsPass == LoadSymbolsPass.LOAD_TYPES) {
                String fullyQualifiedName = type.getFullyQualifiedName();
                this.javaSymbolMap.put(fullyQualifiedName, String.valueOf(str) + name);
                if (type instanceof EnumType) {
                    EnumType enumType = (EnumType) type;
                    if (!this.enumTypes.contains(fullyQualifiedName)) {
                        this.enumTypes.add(fullyQualifiedName);
                        this.enumDefaults.put(fullyQualifiedName, enumType.getValues().get(0).getName());
                        checkForDuplicateEnumValue(str, enumType);
                    }
                }
            } else if (type instanceof MessageType) {
                addFields((MessageType) type);
            }
            addTypes(type.getNestedTypes(), String.valueOf(str) + name + ".", loadSymbolsPass);
        }
    }

    private void checkForDuplicateEnumValue(String str, EnumType enumType) {
        LinkedHashSet linkedHashSet;
        Set<String> set = this.enumValuesByScope.get(str);
        if (set == null) {
            LinkedHashSet linkedHashSet2 = new LinkedHashSet();
            this.enumValuesByScope.put(str, linkedHashSet2);
            linkedHashSet = linkedHashSet2;
        } else {
            linkedHashSet = set;
        }
        for (EnumType.Value value : enumType.getValues()) {
            if (!linkedHashSet.add(value.getName())) {
                throw new WireCompilerException("Duplicate enum value " + value.getName() + " in " + enumType.getFullyQualifiedName() + ", must be unique in parent namespace " + str.substring(0, str.length() - 1));
            }
        }
    }

    private void addFields(MessageType messageType) {
        for (MessageType.Field field : messageType.getFields()) {
            String type = field.getType();
            String str = String.valueOf(messageType.getFullyQualifiedName()) + "$" + field.getName();
            Map<String, FieldInfo> map = this.fieldMap;
            if (!TypeInfo.isScalar(type)) {
                type = fullyQualifiedName(messageType, type);
            }
            map.put(str, new FieldInfo(type, field.getLabel()));
        }
    }

    private String fullyQualifiedName(ProtoFile protoFile, MessageType messageType, String str) {
        if (!typeIsComplete(str)) {
            String packageName = messageType == null ? protoFile.getPackageName() : messageType.getFullyQualifiedName();
            while (!packageName.isEmpty()) {
                String str2 = String.valueOf(packageName) + "." + str;
                if (typeIsComplete(str2)) {
                    return str2;
                }
                packageName = removeTrailingSegment(packageName);
            }
            throw new WireCompilerException("Unknown type " + str + " in message " + (messageType == null ? "<unknown>" : messageType.getName()));
        }
        return str;
    }

    private String shortenJavaName(ProtoFile protoFile, String str) {
        if (str == null) {
            return null;
        }
        String str2 = String.valueOf(getJavaPackage(protoFile)) + "." + this.typeBeingGenerated;
        if (str.startsWith(str2)) {
            return str.substring(str2.length());
        }
        for (String str3 : this.javaSymbolMap.values()) {
            if (str.startsWith(str3)) {
                return str.substring((String.valueOf(getPackageFromFullyQualifiedJavaName(str)) + FilenameUtils.EXTENSION_SEPARATOR).length());
            }
        }
        return str;
    }

    private String protoFileName(String str) {
        int lastIndexOf = str.lastIndexOf(47);
        if (lastIndexOf != -1) {
            str = str.substring(lastIndexOf + 1);
        }
        if (str.endsWith(".proto")) {
            return str.substring(0, str.length() - ".proto".length());
        }
        return str;
    }

    private String getFileName(String str) {
        if (str == null) {
            return null;
        }
        return new File(str).getName();
    }

    private void emitMessageClass(Type type) {
        try {
            this.writer = this.io.getJavaWriter(this.outputDirectory, getJavaPackage(), type.getName());
            this.writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE, new Object[0]);
            this.writer.emitSingleLineComment("Source file: %s", getFileName(this.sourceFileName));
            this.writer.emitPackage(getJavaPackage());
            ArrayList arrayList = new ArrayList();
            getTypes(type, arrayList);
            boolean hasMessage = hasMessage(arrayList);
            boolean hasExtensions = hasExtensions(Arrays.asList(type));
            LinkedHashSet linkedHashSet = new LinkedHashSet();
            if (hasMessage) {
                linkedHashSet.add("com.squareup.wire.Message");
            }
            if ((hasMessage || hasExtensions) && hasFields(type)) {
                linkedHashSet.add("com.squareup.wire.ProtoField");
            }
            if (hasBytesField(arrayList)) {
                linkedHashSet.add("com.squareup.wire.ByteString");
            }
            if (hasEnum(arrayList)) {
                linkedHashSet.add("com.squareup.wire.ProtoEnum");
            }
            if (hasRepeatedField(arrayList)) {
                linkedHashSet.add("java.util.Collections");
                linkedHashSet.add("java.util.List");
            }
            if (hasExtensions) {
                linkedHashSet.add("com.squareup.wire.ExtendableMessage");
                linkedHashSet.add("com.squareup.wire.Extension");
            }
            if (this.emitOptions) {
                if (hasFieldOption(arrayList)) {
                    linkedHashSet.add("com.google.protobuf.FieldOptions");
                }
                if (hasMessageOption(arrayList)) {
                    linkedHashSet.add("com.google.protobuf.MessageOptions");
                }
            }
            ArrayList arrayList2 = new ArrayList();
            getExternalTypes(type, arrayList2);
            Map<String, ?> map = null;
            if (this.emitOptions && (type instanceof MessageType)) {
                Map<String, ?> createMessageOptionsMap = this.optionsMapMaker.createMessageOptionsMap((MessageType) type);
                this.optionsMapMaker.getOptionTypes(createMessageOptionsMap, arrayList2);
                for (MessageType.Field field : ((MessageType) type).getFields()) {
                    this.optionsMapMaker.getOptionTypes(this.optionsMapMaker.createFieldOptionsMap((MessageType) type, field.getOptions()), arrayList2);
                }
                map = createMessageOptionsMap;
            }
            linkedHashSet.addAll(arrayList2);
            TreeSet treeSet = new TreeSet(Message.Datatype.ORDER_BY_NAME);
            TreeSet treeSet2 = new TreeSet(Message.Label.ORDER_BY_NAME);
            getDatatypesAndLabels(type, treeSet, treeSet2);
            treeSet2.remove(Message.Label.OPTIONAL);
            MessageWriter messageWriter = new MessageWriter(this);
            messageWriter.emitHeader(linkedHashSet, treeSet, treeSet2);
            messageWriter.emitType(type, String.valueOf(this.protoFile.getPackageName()) + ".", map, true);
        } finally {
            if (this.writer != null) {
                this.writer.close();
            }
        }
    }

    private void getExternalTypes(Type type, List<String> list) {
        if (type instanceof MessageType) {
            MessageType messageType = (MessageType) type;
            for (MessageType.Field field : messageType.getFields()) {
                String fullyQualifiedJavaName = fullyQualifiedJavaName(messageType, field.getType());
                if (fullyQualifiedJavaName != null) {
                    if (fullyQualifiedNameIsOutsidePackage(fullyQualifiedJavaName)) {
                        list.add(fullyQualifiedJavaName);
                    }
                    String removeTrailingSegment = removeTrailingSegment(fullyQualifiedJavaName);
                    if (javaTypeIsComplete(removeTrailingSegment) && fullyQualifiedNameIsOutsidePackage(removeTrailingSegment)) {
                        list.add(removeTrailingSegment);
                    }
                }
            }
        }
        for (Type type2 : type.getNestedTypes()) {
            getExternalTypes(type2, list);
        }
    }

    private String getPackageFromFullyQualifiedJavaName(String str) {
        while (this.javaSymbolMap.containsValue(str)) {
            str = removeTrailingSegment(str);
        }
        return str;
    }

    private List<String> getExtensionTypes() {
        ArrayList arrayList = new ArrayList();
        for (ExtendDeclaration extendDeclaration : this.protoFile.getExtendDeclarations()) {
            String fullyQualifiedJavaName = fullyQualifiedJavaName(null, extendDeclaration.getFullyQualifiedName());
            if (fullyQualifiedNameIsOutsidePackage(fullyQualifiedJavaName)) {
                arrayList.add(fullyQualifiedJavaName);
            }
            for (MessageType.Field field : extendDeclaration.getFields()) {
                String fullyQualifiedJavaName2 = fullyQualifiedJavaName(null, field.getType());
                if (fullyQualifiedNameIsOutsidePackage(fullyQualifiedJavaName2)) {
                    arrayList.add(fullyQualifiedJavaName2);
                }
            }
        }
        return arrayList;
    }

    private boolean hasExtends() {
        List<ExtendDeclaration> extendDeclarations = this.protoFile.getExtendDeclarations();
        if (!emitOptions()) {
            for (ExtendDeclaration extendDeclaration : extendDeclarations) {
                String fullyQualifiedName = extendDeclaration.getFullyQualifiedName();
                if (!isFieldOptions(fullyQualifiedName) && !isMessageOptions(fullyQualifiedName)) {
                    return true;
                }
            }
        }
        return !extendDeclarations.isEmpty();
    }

    private void emitExtensionClass() {
        this.writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE, new Object[0]);
        this.writer.emitSingleLineComment("Source file: %s", getFileName(this.sourceFileName));
        this.writer.emitPackage(getJavaPackage());
        LinkedHashSet linkedHashSet = new LinkedHashSet();
        if (hasByteStringExtension()) {
            linkedHashSet.add("com.squareup.wire.ByteString");
        }
        linkedHashSet.add("com.squareup.wire.Extension");
        if (hasRepeatedExtension()) {
            linkedHashSet.add("java.util.List");
        }
        List<String> extensionTypes = getExtensionTypes();
        if (emitOptions()) {
            linkedHashSet.addAll(extensionTypes);
        } else {
            for (String str : extensionTypes) {
                if (!isOptionType(str)) {
                    linkedHashSet.add(str);
                }
            }
        }
        this.writer.emitImports(linkedHashSet);
        this.writer.emitEmptyLine();
        String str2 = "Ext_" + this.protoFileName;
        this.writer.beginType(str2, "class", EnumSet.of(Modifier.PUBLIC, Modifier.FINAL));
        this.writer.emitEmptyLine();
        this.writer.beginMethod(null, str2, EnumSet.of(Modifier.PRIVATE), new String[0]);
        this.writer.endMethod();
        this.writer.emitEmptyLine();
        emitExtensions();
        this.writer.endType();
    }

    private void emitExtensions() {
        String format;
        for (ExtendDeclaration extendDeclaration : this.protoFile.getExtendDeclarations()) {
            String fullyQualifiedName = extendDeclaration.getFullyQualifiedName();
            if (emitOptions() || !isOptionType(fullyQualifiedName)) {
                String shortenJavaName = shortenJavaName(javaName(null, fullyQualifiedName));
                for (MessageType.Field field : extendDeclaration.getFields()) {
                    String type = field.getType();
                    String javaName = javaName(null, type);
                    if (javaName == null) {
                        javaName = javaName(null, prefixWithPackageName(type));
                    }
                    String shortenJavaName2 = shortenJavaName(javaName);
                    String compressType = this.writer.compressType(shortenJavaName);
                    String name = field.getName();
                    String prefixWithPackageName = prefixWithPackageName(field.getName());
                    int tag = field.getTag();
                    boolean isScalar = TypeInfo.isScalar(type);
                    boolean z = !isScalar && isEnum(fullyQualifiedName(null, type));
                    String labelString = getLabelString(field, z);
                    if (isScalar) {
                        format = String.format("Extension%n.%1$sExtending(%2$s.class)%n.setName(\"%3$s\")%n.setTag(%4$d)%n.build%5$s()", field.getType(), compressType, prefixWithPackageName, Integer.valueOf(tag), labelString);
                    } else if (z) {
                        format = String.format("Extension%n.enumExtending(%1$s.class, %2$s.class)%n.setName(\"%3$s\")%n.setTag(%4$d)%n.build%5$s()", shortenJavaName2, compressType, prefixWithPackageName, Integer.valueOf(tag), labelString);
                    } else {
                        format = String.format("Extension%n.messageExtending(%1$s.class, %2$s.class)%n.setName(\"%3$s\")%n.setTag(%4$d)%n.build%5$s()", shortenJavaName2, compressType, prefixWithPackageName, Integer.valueOf(tag), labelString);
                    }
                    this.writer.emitField("Extension<" + shortenJavaName + ", " + (FieldInfo.isRepeated(field) ? "List<" + shortenJavaName2 + ">" : shortenJavaName2) + ">", name, EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL), format);
                }
            }
        }
    }

    private static boolean isOptionType(String str) {
        return isMessageOptions(str) || isFieldOptions(str);
    }

    private static boolean isFieldOptions(String str) {
        return "google.protobuf.FieldOptions".equals(str) || "com.google.protobuf.FieldOptions".equals(str);
    }

    private static boolean isMessageOptions(String str) {
        return "google.protobuf.MessageOptions".equals(str) || "com.google.protobuf.MessageOptions".equals(str);
    }

    private String prefixWithPackageName(ProtoFile protoFile, String str) {
        return String.valueOf(protoFile.getPackageName()) + "." + str;
    }

    private String getLabelString(MessageType.Field field, boolean z) {
        switch ($SWITCH_TABLE$com$squareup$protoparser$MessageType$Label()[field.getLabel().ordinal()]) {
            case 1:
                return "Optional";
            case 2:
                return "Required";
            case 3:
                return FieldInfo.isPacked(field, z) ? "Packed" : "Repeated";
            default:
                throw new WireCompilerException("Unknown extension label \"" + field.getLabel() + "\"");
        }
    }

    private boolean hasByteStringExtension() {
        for (ExtendDeclaration extendDeclaration : this.protoFile.getExtendDeclarations()) {
            for (MessageType.Field field : extendDeclaration.getFields()) {
                if ("bytes".equals(field.getType())) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean hasRepeatedExtension() {
        for (ExtendDeclaration extendDeclaration : this.protoFile.getExtendDeclarations()) {
            for (MessageType.Field field : extendDeclaration.getFields()) {
                if (field.getLabel() == MessageType.Label.REPEATED) {
                    return true;
                }
            }
        }
        return false;
    }

    private String toInt(String str) {
        return Integer.toString(new BigDecimal(str).intValue());
    }

    private String toLong(String str) {
        return Long.toString(new BigDecimal(str).longValue());
    }

    private String quoteString(String str) {
        return str == null ? "\"\"" : JavaWriter.stringLiteral(str);
    }

    /* JADX WARN: Removed duplicated region for block: B:7:0x000c  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
    */
    private boolean hasEnum(List<Type> list) {
        for (Type type : list) {
            if ((type instanceof EnumType) || hasEnum(type.getNestedTypes())) {
                return true;
            }
            while (r1.hasNext()) {
            }
        }
        return false;
    }

    private boolean hasExtensions(List<Type> list) {
        for (Type type : list) {
            if (type instanceof MessageType) {
                if (hasExtensions((MessageType) type)) {
                    return true;
                }
            }
            if (hasExtensions(type.getNestedTypes())) {
                return true;
            }
        }
        return false;
    }

    private boolean hasMessage(List<Type> list) {
        for (Type type : list) {
            if (type instanceof MessageType) {
                if (!hasExtensions((MessageType) type)) {
                    return true;
                }
            }
            if (hasMessage(type.getNestedTypes())) {
                return true;
            }
        }
        return false;
    }

    private boolean hasRepeatedField(List<Type> list) {
        for (Type type : list) {
            if (type instanceof MessageType) {
                for (MessageType.Field field : ((MessageType) type).getFields()) {
                    if (FieldInfo.isRepeated(field)) {
                        return true;
                    }
                }
            }
            if (hasRepeatedField(type.getNestedTypes())) {
                return true;
            }
        }
        return false;
    }

    private boolean hasBytesField(List<Type> list) {
        for (Type type : list) {
            if (type instanceof MessageType) {
                for (MessageType.Field field : ((MessageType) type).getFields()) {
                    if ("bytes".equals(field.getType())) {
                        return true;
                    }
                }
            }
            if (hasBytesField(type.getNestedTypes())) {
                return true;
            }
        }
        return false;
    }

    private void getDatatypesAndLabels(Type type, Collection<Message.Datatype> collection, Collection<Message.Label> collection2) {
        if (type instanceof MessageType) {
            for (MessageType.Field field : ((MessageType) type).getFields()) {
                Message.Datatype of = Message.Datatype.of(field.getType());
                Message.Datatype datatype = (of == null && isEnum(fullyQualifiedName((MessageType) type, field.getType()))) ? Message.Datatype.ENUM : of;
                if (datatype != null) {
                    collection.add(datatype);
                }
                MessageType.Label label = field.getLabel();
                switch ($SWITCH_TABLE$com$squareup$protoparser$MessageType$Label()[label.ordinal()]) {
                    case 1:
                        collection2.add(Message.Label.OPTIONAL);
                        break;
                    case 2:
                        collection2.add(Message.Label.REQUIRED);
                        break;
                    case 3:
                        if (FieldInfo.isPacked(field, datatype == Message.Datatype.ENUM)) {
                            collection2.add(Message.Label.PACKED);
                            break;
                        } else {
                            collection2.add(Message.Label.REPEATED);
                            break;
                        }
                    default:
                        throw new AssertionError("Unknown label " + label);
                }
            }
            for (Type type2 : type.getNestedTypes()) {
                getDatatypesAndLabels(type2, collection, collection2);
            }
        }
    }

    private boolean typeIsComplete(String str) {
        return this.javaSymbolMap.containsKey(str);
    }

    private boolean javaTypeIsComplete(String str) {
        if (this.javaSymbols.isEmpty()) {
            this.javaSymbols.addAll(this.javaSymbolMap.values());
        }
        return this.javaSymbols.contains(str);
    }

    private String fullyQualifiedJavaName(MessageType messageType, String str) {
        if (TypeInfo.isScalar(str)) {
            return null;
        }
        return javaName(fullyQualifiedName(messageType, str));
    }
}
